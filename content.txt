--- File: ./config.go ---
package bolt

import "time"

// DefaultConfig returns the default configuration
func DefaultConfig() Config {
	return Config{
		ReadTimeout:       15 * time.Second,
		WriteTimeout:      15 * time.Second,
		IdleTimeout:       60 * time.Second,
		GenerateDocs:      true,
		EnablePooling:     true,
		MaxPoolSize:       1000,
		PreallocateRoutes: 100,
		DevMode:           false,
		DocsConfig: DocsConfig{
			Enabled:     true,
			SpecPath:    "/openapi.json",
			UIPath:      "/docs",
			Title:       "API Documentation",
			Description: "Automatically generated API documentation",
			Version:     "1.0.0",
		},
	}
}

// WithDocs enables or disables documentation
func WithDocs(enabled bool) Option {
	return func(c *Config) {
		c.GenerateDocs = enabled
		c.DocsConfig.Enabled = enabled
	}
}

// WithDocsPath sets documentation paths
func WithDocsPath(specPath, uiPath string) Option {
	return func(c *Config) {
		c.DocsConfig.SpecPath = specPath
		c.DocsConfig.UIPath = uiPath
	}
}

// WithAPIInfo sets API metadata
func WithAPIInfo(title, description, version string) Option {
	return func(c *Config) {
		c.DocsConfig.Title = title
		c.DocsConfig.Description = description
		c.DocsConfig.Version = version
	}
}

// WithDevMode enables development mode
func WithDevMode(enabled bool) Option {
	return func(c *Config) {
		c.DevMode = enabled
	}
}

// WithTimeouts sets server timeouts
func WithTimeouts(read, write, idle time.Duration) Option {
	return func(c *Config) {
		c.ReadTimeout = read
		c.WriteTimeout = write
		c.IdleTimeout = idle
	}
}

// WithPooling enables or disables object pooling
func WithPooling(enabled bool) Option {
	return func(c *Config) {
		c.EnablePooling = enabled
	}
}

// WithCustomDocGenerator sets a custom documentation generator
func WithCustomDocGenerator(gen DocGenerator) Option {
	return func(c *Config) {
		c.DocsConfig.Generator = gen
	}
}

--- File: ./main.go ---
package bolt

--- File: ./app.go ---
package bolt

import (
	"context"
	"log"
	"net"
	"net/http"
	"os"
	"os/signal"
	"reflect"
	"syscall"
	"time"
)

// App is the main application. It can also represent a sub-application within a group.
type App struct {
	router       *Router
	config       Config
	routes       []RouteInfo
	middleware   []Middleware
	errorHandler ErrorHandler
	contextPool  *ContextPool
	bufferPool   *BufferPool
	pathBuilder  *pathBuilder // For efficient path building
	server       *Server
	prefix       string
	parentGroup  *RouteGroup // The group this App instance belongs to
}

// New creates a new top-level App
func New(opts ...Option) *App {
	config := DefaultConfig()

	for _, opt := range opts {
		opt(&config)
	}

	app := &App{
		router:       NewRouter(),
		config:       config,
		routes:       make([]RouteInfo, 0, config.PreallocateRoutes),
		middleware:   make([]Middleware, 0, 8),
		errorHandler: DefaultErrorHandler,
		pathBuilder:  newPathBuilder(),
		parentGroup:  nil, // A new app has no parent
	}

	if config.EnablePooling {
		app.contextPool = NewContextPool()
		app.bufferPool = NewBufferPool()
	}

	return app
}

// Routes returns a copy of all registered routes.
func (a *App) Routes() []RouteInfo {
	return a.routes
}

// Use adds middleware to the application.
func (a *App) Use(middleware ...Middleware) *App {
	a.middleware = append(a.middleware, middleware...)
	return a
}

// Get registers a GET route.
func (a *App) Get(path string, handler Handler) *ChainLink {
	return a.addRoute(MethodGet, path, handler)
}

// Post registers a POST route.
func (a *App) Post(path string, handler Handler) *ChainLink {
	return a.addRoute(MethodPost, path, handler)
}

// Put registers a PUT route.
func (a *App) Put(path string, handler Handler) *ChainLink {
	return a.addRoute(MethodPut, path, handler)
}

// Delete registers a DELETE route.
func (a *App) Delete(path string, handler Handler) *ChainLink {
	return a.addRoute(MethodDelete, path, handler)
}

// Patch registers a PATCH route.
func (a *App) Patch(path string, handler Handler) *ChainLink {
	return a.addRoute(MethodPatch, path, handler)
}

// Head registers a HEAD route.
func (a *App) Head(path string, handler Handler) *ChainLink {
	return a.addRoute(MethodHead, path, handler)
}

// Options registers an OPTIONS route.
func (a *App) Options(path string, handler Handler) *ChainLink {
	return a.addRoute(MethodOptions, path, handler)
}

// PostJSON registers a POST route with automatic JSON parsing.
func (a *App) PostJSON(path string, handler interface{}) *ChainLink {
	wrappedHandler := wrapTypedHandler(handler)
	return a.addRoute(MethodPost, path, wrappedHandler)
}

// PutJSON registers a PUT route with automatic JSON parsing.
func (a *App) PutJSON(path string, handler interface{}) *ChainLink {
	wrappedHandler := wrapTypedHandler(handler)
	return a.addRoute(MethodPut, path, wrappedHandler)
}

// PatchJSON registers a PATCH route with automatic JSON parsing.
func (a *App) PatchJSON(path string, handler interface{}) *ChainLink {
	wrappedHandler := wrapTypedHandler(handler)
	return a.addRoute(MethodPatch, path, wrappedHandler)
}

// compileMiddleware pre-builds the middleware chain for a handler.
func compileMiddleware(middleware []Middleware, finalHandler Handler) Handler {
	if len(middleware) == 0 {
		return finalHandler
	}
	// Build the chain from right to left.
	h := finalHandler
	for i := len(middleware) - 1; i >= 0; i-- {
		h = middleware[i](h)
	}
	return h
}

// addRoute adds a route to the router and pre-compiles the middleware chain.
func (a *App) addRoute(method HTTPMethod, path string, handler Handler) *ChainLink {
	// Use the path builder to avoid string concatenation allocations
	fullPath := a.pathBuilder.build(a.prefix, path)

	// Pre-compile the middleware chain for this specific route.
	finalHandler := compileMiddleware(a.middleware, handler)

	a.router.AddRoute(method, fullPath, finalHandler)

	routeInfo := &RouteInfo{
		Method:  method,
		Path:    fullPath,
		Handler: handler, // Store original handler for documentation
		Group:   a.parentGroup,
	}
	a.routes = append(a.routes, *routeInfo)

	return &ChainLink{app: a, subject: routeInfo}
}

// Group creates a route group.
func (a *App) Group(prefix string, fn GroupFunc) *ChainLink {
	group := &RouteGroup{
		Prefix: a.pathBuilder.build(a.prefix, prefix),
	}

	subApp := &App{
		router:       a.router,
		config:       a.config,
		routes:       a.routes,
		middleware:   a.middleware,
		errorHandler: a.errorHandler,
		contextPool:  a.contextPool,
		bufferPool:   a.bufferPool,
		pathBuilder:  a.pathBuilder,
		prefix:       group.Prefix,
		parentGroup:  group,
	}

	fn(subApp)

	a.routes = subApp.routes

	return &ChainLink{app: a, subject: group}
}

// --- ChainLink Methods ---

// Doc can be called on a route or a group.
func (cl *ChainLink) Doc(doc RouteDoc) *ChainLink {
	switch v := cl.subject.(type) {
	case *RouteInfo:
		if len(cl.app.routes) > 0 {
			cl.app.routes[len(cl.app.routes)-1].Doc = doc
		}
	case *RouteGroup:
		v.Doc = doc
	}
	return cl
}

// Delegate methods for fluent API
func (cl *ChainLink) Get(path string, handler Handler) *ChainLink { return cl.app.Get(path, handler) }
func (cl *ChainLink) Post(path string, handler Handler) *ChainLink { return cl.app.Post(path, handler) }
func (cl *ChainLink) Put(path string, handler Handler) *ChainLink { return cl.app.Put(path, handler) }
func (cl *ChainLink) Delete(path string, handler Handler) *ChainLink {
	return cl.app.Delete(path, handler)
}
func (cl *ChainLink) Patch(path string, handler Handler) *ChainLink {
	return cl.app.Patch(path, handler)
}
func (cl *ChainLink) Head(path string, handler Handler) *ChainLink  { return cl.app.Head(path, handler) }
func (cl *ChainLink) Options(path string, handler Handler) *ChainLink {
	return cl.app.Options(path, handler)
}
func (cl *ChainLink) PostJSON(path string, handler interface{}) *ChainLink {
	return cl.app.PostJSON(path, handler)
}
func (cl *ChainLink) PutJSON(path string, handler interface{}) *ChainLink {
	return cl.app.PutJSON(path, handler)
}
func (cl *ChainLink) PatchJSON(path string, handler interface{}) *ChainLink {
	return cl.app.PatchJSON(path, handler)
}
func (cl *ChainLink) Group(prefix string, fn GroupFunc) *ChainLink { return cl.app.Group(prefix, fn) }

// wrapTypedHandler uses reflection to handle strongly-typed JSON handlers.
func wrapTypedHandler(handler interface{}) Handler {
	return func(c *Context) error {
		handlerValue := reflect.ValueOf(handler)
		handlerType := handlerValue.Type()
		if handlerType.NumIn() != 2 {
			panic("typed handler must accept exactly 2 parameters: (*Context, T)")
		}
		bodyType := handlerType.In(1)
		bodyValue := reflect.New(bodyType)
		bodyPtr := bodyValue.Interface()
		if err := c.BindJSON(bodyPtr); err != nil {
			return err
		}
		results := handlerValue.Call([]reflect.Value{
			reflect.ValueOf(c),
			bodyValue.Elem(),
		})
		if len(results) > 0 && !results[0].IsNil() {
			return results[0].Interface().(error)
		}
		return nil
	}
}

// ServeHTTP is the main entry point for handling requests.
func (a *App) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	var c *Context
	if a.config.EnablePooling {
		c = a.contextPool.Acquire()
		defer a.contextPool.Release(c)
	} else {
		c = &Context{
			params: make(ParamMap, 8),
			query:  make(QueryValues, 8),
		}
	}
	c.Request = r
	c.Response = w
	c.app = a

	parsedQuery := r.URL.Query()
	for k, v := range parsedQuery {
		c.query[k] = v
	}

	handler, params := a.router.GetValue(HTTPMethod(r.Method), r.URL.Path)
	if handler == nil {
		a.errorHandler(c, ErrNotFound)
		return
	}
	c.params = params

	if err := handler(c); err != nil {
		a.errorHandler(c, err)
	}

	// Release params back to the pool if it was acquired by the router
	if params != nil && a.router.paramPool != nil {
		a.router.releaseParamMap(params)
	}
}

// DefaultErrorHandler provides basic error handling.
func DefaultErrorHandler(c *Context, err error) {
	if err == nil {
		return
	}
	code := http.StatusInternalServerError
	message := "Internal Server Error"
	switch err {
	case ErrNotFound:
		code = http.StatusNotFound
		message = "Not Found"
	case ErrBadRequest:
		code = http.StatusBadRequest
		message = "Bad Request"
	}

	// Avoid writing header twice
	if c.StatusCode == 0 {
		c.JSON(code, map[string]string{"error": message})
	}
}

// SetErrorHandler sets a custom error handler for the application.
func (a *App) SetErrorHandler(handler ErrorHandler) *App {
	a.errorHandler = handler
	return a
}

// setupDocs configures documentation endpoints.
func (a *App) setupDocs() {
	if !a.config.GenerateDocs || !a.config.DocsConfig.Enabled {
		return
	}
	specPath := a.config.DocsConfig.SpecPath
	a.Get(specPath, func(c *Context) error {
		spec := a.GenerateDocs()
		return c.JSON(http.StatusOK, spec)
	})
	uiPath := a.config.DocsConfig.UIPath
	a.Get(uiPath, ServeSwaggerUI(specPath))
	if a.config.DevMode && a.server != nil && a.server.Addr != "" {
		log.Printf("ðŸ“š API Documentation available at: http://localhost%s%s", a.server.Addr, uiPath)
	}
}

// Listen starts the HTTP server.
func (a *App) Listen(addr string) error {
	a.server = &http.Server{
		Addr:         addr,
		Handler:      a,
		ReadTimeout:  a.config.ReadTimeout,
		WriteTimeout: a.config.WriteTimeout,
		IdleTimeout:  a.config.IdleTimeout,
	}
	go a.handleShutdown()
	if a.config.DevMode {
		log.Printf("ðŸš€ Server starting on http://localhost%s", addr)
	}
	a.setupDocs()
	listener, err := net.Listen("tcp", addr)
	if err != nil {
		return err
	}
	return a.server.Serve(listener)
}

// handleShutdown gracefully shuts down the server.
func (a *App) handleShutdown() {
	quit := make(chan os.Signal, 1)
	signal.Notify(quit, os.Interrupt, syscall.SIGTERM)
	<-quit
	log.Println("ðŸ›‘ Shutting down server...")
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()
	if err := a.server.Shutdown(ctx); err != nil {
		log.Printf("Server forced to shutdown: %v", err)
	}
	log.Println("âœ… Server stopped")
}

// Shutdown provides a way to programmatically shut down the server.
func (a *App) Shutdown(ctx context.Context) error {
	if a.server == nil {
		return nil
	}
	return a.server.Shutdown(ctx)
}

--- File: ./docs.go ---
package bolt

import (
	"fmt"
	"net/http"
	"reflect"
	"strings"
)

// OpenAPISpec represents OpenAPI 3.0 specification
type OpenAPISpec struct {
	OpenAPI    string                           `json:"openapi"`
	Info       OpenAPIInfo                      `json:"info"`
	Paths      map[string]map[string]Operation  `json:"paths"`
	Components Components                       `json:"components,omitempty"`
	Tags       []Tag                            `json:"tags,omitempty"`
}

// Tag represents an OpenAPI Tag Object for grouping operations.
type Tag struct {
	Name        string `json:"name"`
	Description string `json:"description,omitempty"`
}

// OpenAPIInfo contains API metadata
type OpenAPIInfo struct {
	Title       string `json:"title"`
	Description string `json:"description"`
	Version     string `json:"version"`
}

// Operation describes a single API operation
type Operation struct {
	Summary     string              `json:"summary,omitempty"`
	Description string              `json:"description,omitempty"`
	Tags        []string            `json:"tags,omitempty"`
	Parameters  []Parameter         `json:"parameters,omitempty"`
	RequestBody *RequestBody        `json:"requestBody,omitempty"`
	Responses   map[string]Response `json:"responses"`
}

// Parameter describes a single operation parameter
type Parameter struct {
	Name        string `json:"name"`
	In          string `json:"in"`
	Description string `json:"description,omitempty"`
	Required    bool   `json:"required"`
	Schema      Schema `json:"schema"`
}

// RequestBody describes a request body
type RequestBody struct {
	Description string               `json:"description,omitempty"`
	Required    bool                 `json:"required"`
	Content     map[string]MediaType `json:"content"`
}

// MediaType describes media type and schema
type MediaType struct {
	Schema Schema `json:"schema"`
}

// Response describes a single response
type Response struct {
	Description string               `json:"description"`
	Content     map[string]MediaType `json:"content,omitempty"`
}

// Schema describes data structure
type Schema struct {
	Type       string            `json:"type,omitempty"`
	Properties map[string]Schema `json:"properties,omitempty"`
	Items      *Schema           `json:"items,omitempty"`
	Required   []string          `json:"required,omitempty"`
	Ref        string            `json:"$ref,omitempty"`
}

// Components holds reusable schema objects
type Components struct {
	Schemas map[string]Schema `json:"schemas,omitempty"`
}

// GenerateDocs generates OpenAPI documentation, combining group and route docs.
func (a *App) GenerateDocs() *OpenAPISpec {
	if a.config.DocsConfig.Generator != nil {
		return a.config.DocsConfig.Generator(a)
	}

	spec := &OpenAPISpec{
		OpenAPI: "3.0.0",
		Info: OpenAPIInfo{
			Title:       a.config.DocsConfig.Title,
			Description: a.config.DocsConfig.Description,
			Version:     a.config.DocsConfig.Version,
		},
		Paths: make(map[string]map[string]Operation),
		Components: Components{
			Schemas: make(map[string]Schema),
		},
		Tags: make([]Tag, 0),
	}

	// Process groups to create top-level tags for Swagger UI
	processedGroups := make(map[string]bool)
	for _, route := range a.routes {
		if route.Group != nil && !processedGroups[route.Group.Prefix] {
			parts := strings.Split(strings.Trim(route.Group.Prefix, "/"), "/")
			tagName := parts[len(parts)-1]

			if tagName != "" {
				spec.Tags = append(spec.Tags, Tag{
					Name:        tagName,
					Description: route.Group.Doc.Summary,
				})
				processedGroups[route.Group.Prefix] = true
			}
		}
	}

	for _, route := range a.routes {
		if spec.Paths[route.Path] == nil {
			spec.Paths[route.Path] = make(map[string]Operation)
		}

		finalDoc := route.Doc
		var finalTags []string

		if route.Group != nil {
			parts := strings.Split(strings.Trim(route.Group.Prefix, "/"), "/")
			tagName := parts[len(parts)-1]
			if tagName != "" {
				finalTags = append(finalTags, tagName)
			}
			finalTags = append(finalTags, route.Group.Doc.Tags...)
			if route.Group.Doc.Description != "" {
				finalDoc.Description = route.Group.Doc.Description + "\n\n" + finalDoc.Description
			}
		}
		finalTags = append(finalTags, route.Doc.Tags...)

		operation := Operation{
			Summary:     finalDoc.Summary,
			Description: finalDoc.Description,
			Tags:        finalTags,
			Responses:   make(map[string]Response),
		}

		params := extractPathParams(route.Path)
		for _, param := range params {
			operation.Parameters = append(operation.Parameters, Parameter{
				Name:     param,
				In:       "path",
				Required: true,
				Schema:   Schema{Type: "string"},
			})
		}

		if finalDoc.Request != nil {
			schemaName := getTypeName(finalDoc.Request)
			spec.Components.Schemas[schemaName] = generateSchema(finalDoc.Request)
			operation.RequestBody = &RequestBody{
				Required: true,
				Content: map[string]MediaType{
					"application/json": {Schema: Schema{Ref: "#/components/schemas/" + schemaName}},
				},
			}
		}

		if finalDoc.Response != nil {
			schemaName := getTypeName(finalDoc.Response)
			spec.Components.Schemas[schemaName] = generateSchema(finalDoc.Response)
			operation.Responses["200"] = Response{
				Description: "Success",
				Content: map[string]MediaType{
					"application/json": {Schema: Schema{Ref: "#/components/schemas/" + schemaName}},
				},
			}
		} else {
			operation.Responses["200"] = Response{Description: "Success"}
		}

		methodStr := strings.ToLower(string(route.Method))
		spec.Paths[route.Path][methodStr] = operation
	}

	return spec
}

func extractPathParams(path string) []string {
	var params []string
	parts := strings.Split(path, "/")
	for _, part := range parts {
		if len(part) > 0 && (part[0] == ':' || part[0] == '*') {
			params = append(params, part[1:])
		}
	}
	return params
}

func getTypeName(v interface{}) string {
	t := reflect.TypeOf(v)
	if t.Kind() == reflect.Ptr {
		t = t.Elem()
	}
	name := t.Name()
	if name == "" {
		name = "Object"
	}
	return name
}

func generateSchema(v interface{}) Schema {
	t := reflect.TypeOf(v)
	if t.Kind() == reflect.Ptr {
		t = t.Elem()
	}
	schema := Schema{Type: "object", Properties: make(map[string]Schema)}
	if t.Kind() != reflect.Struct {
		return Schema{Type: getJSONType(t)}
	}
	var required []string
	for i := 0; i < t.NumField(); i++ {
		field := t.Field(i)
		jsonTag := field.Tag.Get("json")
		if jsonTag == "" || jsonTag == "-" {
			continue
		}
		parts := strings.Split(jsonTag, ",")
		fieldName := parts[0]
		fieldSchema := Schema{Type: getJSONType(field.Type)}
		if field.Type.Kind() == reflect.Struct {
			fieldSchema = generateSchema(reflect.New(field.Type).Interface())
		}
		if field.Type.Kind() == reflect.Slice {
			itemType := field.Type.Elem()
			fieldSchema.Type = "array"
			fieldSchema.Items = &Schema{Type: getJSONType(itemType)}
			if itemType.Kind() == reflect.Struct {
				*fieldSchema.Items = generateSchema(reflect.New(itemType).Interface())
			}
		}
		schema.Properties[fieldName] = fieldSchema
		isOmitEmpty := false
		for _, part := range parts[1:] {
			if part == "omitempty" {
				isOmitEmpty = true
				break
			}
		}
		if !isOmitEmpty {
			required = append(required, fieldName)
		}
	}
	if len(required) > 0 {
		schema.Required = required
	}
	return schema
}

func getJSONType(t reflect.Type) string {
	if t.Kind() == reflect.Ptr {
		t = t.Elem()
	}
	switch t.Kind() {
	case reflect.String:
		return "string"
	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64,
		reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:
		return "integer"
	case reflect.Float32, reflect.Float64:
		return "number"
	case reflect.Bool:
		return "boolean"
	case reflect.Slice, reflect.Array:
		return "array"
	case reflect.Struct, reflect.Map:
		return "object"
	default:
		return "string"
	}
}

// ServeSwaggerUI serves the Swagger UI HTML page.
func ServeSwaggerUI(specPath string) Handler {
	html := fmt.Sprintf(`<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>API Documentation</title>
    <link rel="stylesheet" href="https://unpkg.com/swagger-ui-dist@5/swagger-ui.css" />
</head>
<body>
    <div id="swagger-ui"></div>
    <script src="https://unpkg.com/swagger-ui-dist@5/swagger-ui-bundle.js"></script>
    <script>
        window.onload = function() {
            SwaggerUIBundle({
                url: '%s',
                dom_id: '#swagger-ui',
                presets: [
                    SwaggerUIBundle.presets.apis,
                    SwaggerUIBundle.SwaggerUIStandalonePreset
                ],
            })
        }
    </script>
</body>
</html>`, specPath)

	return func(c *Context) error {
		c.Response.Header().Set("Content-Type", "text/html; charset=utf-8")
		c.Response.WriteHeader(http.StatusOK)
		_, err := c.Response.Write([]byte(html))
		return err
	}
}

--- File: ./.gitignore ---
# If you prefer the allow list template instead of the deny list, see community template:
# https://github.com/github/gitignore/blob/main/community/Golang/Go.AllowList.gitignore
#
# Binaries for programs and plugins
*.exe
*.exe~
*.dll
*.so
*.dylib

# Test binary, built with `go test -c`
*.test

# Code coverage profiles and other test artifacts
*.out
coverage.*
*.coverprofile
profile.cov

# Dependency directories (remove the comment below to include it)
# vendor/

# Go workspace file
go.work
go.work.sum

# env file
.env

# Editor/IDE
# .idea/
# .vscode/

--- File: ./router.go ---
package bolt

import (
	"sync"
	"unsafe"
)

// nodeType represents the type of a node in the radix tree.
type nodeType uint8

const (
	staticNode   nodeType = iota // A static path segment, e.g., "/users"
	paramNode                    // A parameter, e.g., "/:id"
	wildcardNode                 // A catch-all wildcard, e.g., "/*path"
)

// Node represents a node in the radix tree.
type Node struct {
	path      string
	indices   []byte // Changed from string to []byte
	children  []*Node
	handlers  map[HTTPMethod]Handler
	nodeType  nodeType
	priority  uint32
	paramName string
}

// Router implements a high-performance radix tree router.
type Router struct {
	trees     map[HTTPMethod]*Node
	paramPool *sync.Pool // Pool for ParamMap to reduce allocations
}

// NewRouter creates a new router.
func NewRouter() *Router {
	return &Router{
		trees: make(map[HTTPMethod]*Node),
		paramPool: &sync.Pool{
			New: func() interface{} {
				// Initialize with a default capacity
				return make(ParamMap, DefaultParamsSize)
			},
		},
	}
}

// acquireParamMap gets a ParamMap from the pool.
func (r *Router) acquireParamMap() ParamMap {
	return r.paramPool.Get().(ParamMap)
}

// releaseParamMap returns a ParamMap to the pool after clearing it.
func (r *Router) releaseParamMap(p ParamMap) {
	if p == nil {
		return
	}
	// If the map grew too large, don't return it to the pool.
	// Let the GC handle it and create a new, smaller one next time.
	if len(p) > MaxParams {
		return
	}
	for k := range p {
		delete(p, k)
	}
	r.paramPool.Put(p)
}

// unsafeBytesToString converts a byte slice to a string without allocation.
func unsafeBytesToString(b []byte) string {
	return *(*string)(unsafe.Pointer(&b))
}

// AddRoute adds a new route to the router.
func (r *Router) AddRoute(method HTTPMethod, path string, handler Handler) {
	if path[0] != '/' {
		panic("path must begin with '/'")
	}

	root := r.trees[method]
	if root == nil {
		root = &Node{}
		r.trees[method] = root
	}

	addRoute(root, path, handler, method)
}

// (addRoute and insertChild logic remains the same as it's complex and not the primary bottleneck)
func addRoute(n *Node, path string, handler Handler, method HTTPMethod) {
	n.priority++
walk:
	for {
		i := 0
		max := len(path)
		if len(n.path) < max {
			max = len(n.path)
		}
		for i < max && path[i] == n.path[i] {
			i++
		}
		if i < len(n.path) {
			child := &Node{
				path:      n.path[i:],
				indices:   n.indices,
				children:  n.children,
				handlers:  n.handlers,
				priority:  n.priority - 1,
				nodeType:  n.nodeType,
				paramName: n.paramName,
			}
			n.children = []*Node{child}
			n.indices = []byte{n.path[i]}
			n.path = path[:i]
			n.handlers = nil
			n.paramName = ""
			n.nodeType = staticNode
		}
		if i < len(path) {
			path = path[i:]
			c := path[0]
			for j := 0; j < len(n.indices); j++ {
				if c == n.indices[j] {
					n = n.children[j]
					continue walk
				}
			}
			n.indices = append(n.indices, c)
			child := &Node{}
			n.children = append(n.children, child)
			n = child
			insertChild(n, path, handler, method)
			return
		}
		if n.handlers == nil {
			n.handlers = make(map[HTTPMethod]Handler)
		}
		n.handlers[method] = handler
		return
	}
}

func insertChild(n *Node, path string, handler Handler, method HTTPMethod) {
	var offset int
	for offset = 0; offset < len(path); offset++ {
		c := path[offset]
		if c == ':' || c == '*' {
			break
		}
	}
	if offset < len(path) {
		c := path[offset]
		if c == ':' {
			end := offset + 1
			for end < len(path) && path[end] != '/' {
				end++
			}
			n.path = path[:end]
			n.paramName = path[offset+1 : end]
			n.nodeType = paramNode
			if end < len(path) {
				child := &Node{}
				n.indices = []byte{path[end]}
				n.children = []*Node{child}
				addRoute(child, path[end:], handler, method)
				return
			}
		} else if c == '*' {
			n.path = path
			n.paramName = path[offset+1:]
			n.nodeType = wildcardNode
		}
	} else {
		n.path = path
	}
	if n.handlers == nil {
		n.handlers = make(map[HTTPMethod]Handler)
	}
	n.handlers[method] = handler
}


// GetValue finds a handler and extracts parameters for a given path.
// It now uses a pool for the parameters map to reduce allocations.
func (r *Router) GetValue(method HTTPMethod, path string) (Handler, ParamMap) {
	root := r.trees[method]
	if root == nil {
		return nil, nil
	}

	var handler Handler
	var params ParamMap = nil // Initialize to nil
	pathBytes := []byte(path)

walk:
	for {
		prefixLen := len(root.path)
		if len(pathBytes) >= prefixLen && unsafeBytesToString(pathBytes[:prefixLen]) == root.path {
			pathBytes = pathBytes[prefixLen:]

			if len(pathBytes) == 0 {
				// Path matches exactly
				if root.handlers != nil {
					handler = root.handlers[method]
				}
				return handler, params
			}

			// Path continues, look for a matching child
			c := pathBytes[0]
			for i, index := range root.indices {
				if c == index {
					root = root.children[i]
					continue walk
				}
			}

			// No static child found, check for param/wildcard
			if len(root.children) > 0 {
				child := root.children[0]
				if child.nodeType == paramNode {
					root = child
					end := 0
					for end < len(pathBytes) && pathBytes[end] != '/' {
						end++
					}

					if params == nil {
						params = r.acquireParamMap()
					}
					params[root.paramName] = unsafeBytesToString(pathBytes[:end])
					pathBytes = pathBytes[end:]
					continue walk
				}

				if child.nodeType == wildcardNode {
					root = child
					if params == nil {
						params = r.acquireParamMap()
					}
					params[root.paramName] = unsafeBytesToString(pathBytes)
					handler = root.handlers[method]
					return handler, params
				}
			}

			// No route matched
			if params != nil {
				r.releaseParamMap(params)
			}
			return nil, nil
		}
		
		// This node's path does not match
		if params != nil {
			r.releaseParamMap(params)
		}
		return nil, nil
	}
}

--- File: ./pool.go ---
package bolt

import (
	"bytes"
	"sync"
)

const (
	// MaxParams is the threshold for resetting the params map.
	// If a request has more than this many params, we create a new map
	// instead of clearing the old one to avoid memory bloat.
	MaxParams = 8
	// DefaultParamsSize is the initial size for new/reset params maps.
	DefaultParamsSize = 4
)

// ContextPool manages Context object reuse
type ContextPool struct {
	pool sync.Pool
}

// NewContextPool creates a new context pool with optimized initial sizes.
func NewContextPool() *ContextPool {
	return &ContextPool{
		pool: sync.Pool{
			New: func() interface{} {
				return &Context{
					// Most routes have fewer than 4 params or query values.
					params: make(ParamMap, DefaultParamsSize),
					query:  make(QueryValues, DefaultParamsSize),
				}
			},
		},
	}
}

// Acquire gets a Context from the pool
func (p *ContextPool) Acquire() *Context {
	return p.pool.Get().(*Context)
}

// Release returns a Context to the pool with a more aggressive clearing strategy.
func (p *ContextPool) Release(c *Context) {
	// Reset basic fields
	c.Request = nil
	c.Response = nil
	c.app = nil
	c.StatusCode = 0
	c.params = nil // The router is responsible for pooling params

	// If the query map grew too large, create a new one to prevent memory bloat.
	// Otherwise, just clear the existing one.
	if len(c.query) > MaxParams {
		c.query = make(QueryValues, DefaultParamsSize)
	} else {
		for k := range c.query {
			delete(c.query, k)
		}
	}

	p.pool.Put(c)
}

// BufferPool manages byte buffer reuse
type BufferPool struct {
	pool sync.Pool
}

// NewBufferPool creates a new buffer pool that pools *bytes.Buffer objects
func NewBufferPool() *BufferPool {
	return &BufferPool{
		pool: sync.Pool{
			New: func() interface{} {
				return new(bytes.Buffer)
			},
		},
	}
}

// Acquire gets a buffer from the pool
func (p *BufferPool) Acquire() *bytes.Buffer {
	return p.pool.Get().(*bytes.Buffer)
}

// Release returns a buffer to the pool after resetting it
func (p *BufferPool) Release(buf *bytes.Buffer) {
	buf.Reset()
	p.pool.Put(buf)
}

--- File: ./content.txt ---

--- File: ./LICENSE ---
MIT License

Copyright (c) 2025 Mirai

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

--- File: ./errors.go ---
package bolt

import "errors"

var (
	ErrBadRequest      = errors.New("bad request")
	ErrUnauthorized    = errors.New("unauthorized")
	ErrForbidden       = errors.New("forbidden")
	ErrNotFound        = errors.New("not found")
	ErrInvalidRedirect = errors.New("invalid redirect code")
)

--- File: ./examples/route_groups/route_groups.go ---
package main

import (  
    "log"  
    "bolt"  
)

type User struct {  
    Name string `json:"name"`  
}

func main() {  
    app := bolt.New(bolt.WithDevMode(true))  
      
    // API v1 group  
    app.Group("/api/v1", func(api *bolt.App) {  
          
        api.Get("/users", func(c *bolt.Context) error {  
            return c.JSON(200, []map[string]string{{"id": "1", "name": "User 1"}})  
        }).Doc(bolt.RouteDoc{Summary: "Get all users"})  
          
        api.PostJSON("/users", func(c *bolt.Context, user User) error {  
            return c.JSON(201, user)  
        }).Doc(bolt.RouteDoc{Summary: "Create a user", Request: User{}})  
    })  
      
    log.Fatal(app.Listen(":3000"))  
}
--- File: ./examples/basic_app/basic_app.go ---
package main

import (  
    "log"  
    "bolt"  
    "strconv"
)

type User struct {  
    ID    int    `json:"id"`  
    Name  string `json:"name"`  
    Email string `json:"email"`  
}

type CreateUserRequest struct {  
    Name  string `json:"name"`  
    Email string `json:"email"`  
}

func main() {
    app := bolt.New(  
        bolt.WithAPIInfo("User API", "User management API", "1.0.0"),  
        bolt.WithDevMode(true),  
    )  
      
    // The new fluent API in action.  
    app.Get("/", func(c *bolt.Context) error {  
        return c.JSON(200, map[string]string{  
            "message": "Hello World",  
        })  
    }).Doc(bolt.RouteDoc{  
        Summary:     "Welcome endpoint",  
        Description: "Returns a welcome message",  
    }).Get("/users/:id", func(c *bolt.Context) error {  
        id, _ := strconv.Atoi(c.Param("id"))
        user := User{ ID: id, Name: "John Doe", Email: "john@example.com" }  
        return c.JSON(200, user)  
    }).Doc(bolt.RouteDoc{  
        Summary:  "Get user by ID",  
        Response: User{},  
    }).PostJSON("/users", func(c *bolt.Context, req CreateUserRequest) error {  
        user := User{ ID: 2, Name: req.Name, Email: req.Email }  
        return c.JSON(201, user)  
    }).Doc(bolt.RouteDoc{  
        Summary:  "Create new user",  
        Request:  CreateUserRequest{},  
        Response: User{},  
    })  
      
    log.Fatal(app.Listen(":3000"))  
}
--- File: ./examples/middlewares/middlewares.go ---
package main

import (  
    "log"  
    "time"  
    "bolt"  
)

func Logger() bolt.Middleware {  
    return func(next bolt.Handler) bolt.Handler {  
        return func(c *bolt.Context) error {  
            start := time.Now()  
            err := next(c)  
            duration := time.Since(start)  
            log.Printf("[%s] %s %d (%v)", c.Request.Method, c.Request.URL.Path, c.StatusCode, duration)  
            return err  
        }  
    }  
}

func main() {  
    app := bolt.New(bolt.WithDevMode(true))  
      
    // Global middleware is still applied to the app instance.  
    app.Use(Logger())  
      
    app.Get("/", func(c *bolt.Context) error {  
        return c.JSON(200, map[string]string{"message": "Public"})  
    }).Doc(bolt.RouteDoc{Summary: "Public endpoint"})  
      
    log.Fatal(app.Listen(":3000"))  
}
--- File: ./types.go ---
package bolt

import (
	"net/http"
	"net/url"
	"reflect"
	"time"
)

// Handler is the standard request handler function
type Handler func(*Context) error

// TypedHandler is a generic handler that receives parsed request body
type TypedHandler[T any] func(*Context, T) error

// Middleware wraps a handler to add functionality
type Middleware func(Handler) Handler

// ErrorHandler handles errors from handlers
type ErrorHandler func(*Context, error)

// GroupFunc defines routes within a route group
type GroupFunc func(*App)

// DocGenerator generates OpenAPI documentation
type DocGenerator func(*App) *OpenAPISpec

// HTTPMethod represents HTTP methods
type HTTPMethod string

const (
	MethodGet     HTTPMethod = "GET"
	MethodPost    HTTPMethod = "POST"
	MethodPut     HTTPMethod = "PUT"
	MethodDelete  HTTPMethod = "DELETE"
	MethodPatch   HTTPMethod = "PATCH"
	MethodHead    HTTPMethod = "HEAD"
	MethodOptions HTTPMethod = "OPTIONS"
)

// RouteGroup represents a group of routes with a shared prefix and documentation.
type RouteGroup struct {
	Prefix string
	Doc    RouteDoc
}

// RouteInfo stores metadata about a registered route.
type RouteInfo struct {
	Method  HTTPMethod
	Path    string
	Handler Handler
	Doc     RouteDoc
	Group   *RouteGroup // Link to the parent group
}

// ChainLink represents the current state of a fluent configuration chain.
type ChainLink struct {
	app     *App
	subject interface{} // The subject can be *RouteInfo or *RouteGroup
}

// RouteDoc stores documentation metadata for a route
type RouteDoc struct {
	Summary     string
	Description string
	Tags        []string
	Request     interface{}
	Response    interface{}
}

// Config configures the entire application
type Config struct {
	ReadTimeout       time.Duration
	WriteTimeout      time.Duration
	IdleTimeout       time.Duration
	GenerateDocs      bool
	DocsConfig        DocsConfig
	EnablePooling     bool
	MaxPoolSize       int
	PreallocateRoutes int
	DevMode           bool
}

// DocsConfig configures automatic documentation
type DocsConfig struct {
	Enabled     bool
	SpecPath    string
	UIPath      string
	Title       string
	Description string
	Version     string
	Generator   DocGenerator
}

// Option is a functional option for Config
type Option func(*Config)

// ParamMap stores URL parameters
type ParamMap map[string]string

// QueryValues stores query parameters
type QueryValues url.Values

// StatusCode represents HTTP status codes
type StatusCode int

// ContentType represents content types
type ContentType string

const (
	ContentTypeJSON ContentType = "application/json; charset=utf-t"
	ContentTypeText ContentType = "text/plain; charset=utf-8"
	ContentTypeHTML ContentType = "text/html; charset=utf-8"
)

// ResponseWriter wraps http.ResponseWriter
type ResponseWriter http.ResponseWriter

// Request wraps http.Request
type Request = http.Request

// Server wraps http.Server
type Server = http.Server

// Listener wraps net.Listener
type Listener interface {
	Accept() (interface{}, error)
	Close() error
	Addr() interface{}
}

// HandlerInfo contains information about a handler function for documentation
type HandlerInfo struct {
	Fn         interface{}
	InputType  reflect.Type
	OutputType reflect.Type
}

--- File: ./context.go ---
package bolt

import (
	"encoding/json"
	"io"
	"net/url"
	"strconv"
)

// Context represents the request context
type Context struct {
	Request    *Request
	Response   ResponseWriter
	app        *App
	params     ParamMap
	query      QueryValues
	StatusCode StatusCode
}

// Param gets a URL parameter by key
func (c *Context) Param(key string) string {
	if c.params == nil {
		return ""
	}
	return c.params[key]
}

// Query gets a query parameter by key
func (c *Context) Query(key string) string {
	return url.Values(c.query).Get(key)
}

// QueryInt gets a query parameter as integer with default value
func (c *Context) QueryInt(key string, defaultVal int) int {
	val := c.Query(key)
	if val == "" {
		return defaultVal
	}
	i, err := strconv.Atoi(val)
	if err != nil {
		return defaultVal
	}
	return i
}

// QueryBool gets a query parameter as boolean
func (c *Context) QueryBool(key string, defaultVal bool) bool {
	val := c.Query(key)
	if val == "" {
		return defaultVal
	}
	b, err := strconv.ParseBool(val)
	if err != nil {
		return defaultVal
	}
	return b
}

// JSON sends a JSON response using a pooled buffer to avoid allocations.
func (c *Context) JSON(status int, v interface{}) error {
	c.StatusCode = StatusCode(status)

	// Set Content-Type only if it hasn't been set already to avoid overhead.
	if c.Response.Header().Get("Content-Type") == "" {
		c.Response.Header().Set("Content-Type", string(ContentTypeJSON))
	}

	// Use the buffer pool for an efficient JSON encoding path
	if c.app != nil && c.app.bufferPool != nil {
		buf := c.app.bufferPool.Acquire()
		defer c.app.bufferPool.Release(buf)

		// The encoder writes to our temporary buffer
		if err := json.NewEncoder(buf).Encode(v); err != nil {
			return err
		}

		c.Response.WriteHeader(status)
		_, err := c.Response.Write(buf.Bytes())
		return err
	}

	// Fallback path if pooling is disabled
	c.Response.WriteHeader(status)
	return json.NewEncoder(c.Response).Encode(v)
}

// String sends a plain text response
func (c *Context) String(status int, s string) error {
	c.StatusCode = StatusCode(status)
	if c.Response.Header().Get("Content-Type") == "" {
		c.Response.Header().Set("Content-Type", string(ContentTypeText))
	}
	c.Response.WriteHeader(status)
	_, err := c.Response.Write([]byte(s))
	return err
}

// HTML sends an HTML response
func (c *Context) HTML(status int, html string) error {
	c.StatusCode = StatusCode(status)
	if c.Response.Header().Get("Content-Type") == "" {
		c.Response.Header().Set("Content-Type", string(ContentTypeHTML))
	}
	c.Response.WriteHeader(status)
	_, err := c.Response.Write([]byte(html))
	return err
}

// Bytes sends a byte response with custom content type
func (c *Context) Bytes(status int, contentType ContentType, data []byte) error {
	c.StatusCode = StatusCode(status)
	c.Response.Header().Set("Content-Type", string(contentType))
	c.Response.WriteHeader(status)
	_, err := c.Response.Write(data)
	return err
}

// BindJSON binds request body to a struct
func (c *Context) BindJSON(v interface{}) error {
	if c.Request.Body == nil {
		return ErrBadRequest
	}

	// Use buffer pool if available for efficiency
	if c.app != nil && c.app.bufferPool != nil {
		buf := c.app.bufferPool.Acquire()
		defer c.app.bufferPool.Release(buf)

		lr := io.LimitReader(c.Request.Body, 10<<20) // 10MB limit

		_, err := io.Copy(buf, lr)
		if err != nil {
			return err
		}

		if err := json.Unmarshal(buf.Bytes(), v); err != nil {
			return ErrBadRequest
		}
		return nil
	}

	// Fallback for when pooling is disabled
	lr := io.LimitReader(c.Request.Body, 10<<20)
	decoder := json.NewDecoder(lr)
	if err := decoder.Decode(v); err != nil {
		return ErrBadRequest
	}
	return nil
}

// SetHeader sets a response header
func (c *Context) SetHeader(key, value string) {
	c.Response.Header().Set(key, value)
}

// GetHeader gets a request header
func (c *Context) GetHeader(key string) string {
	return c.Request.Header.Get(key)
}

// Status sets the response status code
func (c *Context) Status(code StatusCode) *Context {
	c.StatusCode = code
	return c
}

// NoContent sends a 204 No Content response
func (c *Context) NoContent() error {
	c.StatusCode = 204
	c.Response.WriteHeader(204)
	return nil
}

// Redirect sends a redirect response
func (c *Context) Redirect(code int, url string) error {
	if code < 300 || code > 308 {
		return ErrInvalidRedirect
	}
	c.Response.Header().Set("Location", url)
	c.Response.WriteHeader(code)
	return nil
}


--- File: ./utils.go ---
package bolt

import "sync"

// pathBuilder helps build paths efficiently, avoiding string concatenations.
type pathBuilder struct {
	buf []byte
}

// newPathBuilder creates a new path builder.
func newPathBuilder() *pathBuilder {
	return &pathBuilder{
		buf: make([]byte, 0, 128), // Pre-allocate a reasonable size
	}
}

// build combines a prefix and a path into a single string.
func (pb *pathBuilder) build(prefix, path string) string {
	pb.buf = pb.buf[:0] // Reset buffer without reallocating
	pb.buf = append(pb.buf, prefix...)
	pb.buf = append(pb.buf, path...)
	return string(pb.buf)
}

// --- String Interning for Path Segments ---

var (
	pathIntern   = make(map[string]string)
	pathInternMu sync.RWMutex
)

// internPath returns a shared string for a given path segment,
// reducing memory usage for common route parts.
func internPath(path string) string {
	pathInternMu.RLock()
	if interned, ok := pathIntern[path]; ok {
		pathInternMu.RUnlock()
		return interned
	}
	pathInternMu.RUnlock()

	pathInternMu.Lock()
	// Double-check in case another goroutine just added it
	if interned, ok := pathIntern[path]; ok {
		pathInternMu.Unlock()
		return interned
	}
	pathIntern[path] = path
	pathInternMu.Unlock()
	return path
}

--- File: ./go.mod ---
module bolt

go 1.25
--- File: ./internal/tools/json2bench/json2bench.go ---
package main

import (
	"encoding/json"
	"fmt"
	"io"
	"log"
	"os"
)

// TestEvent corresponds to a single line of the `go test -json` output.
// We only need a few fields for this conversion.
type TestEvent struct {
	Action string `json:"Action"`
	Output string `json:"Output,omitempty"`
}

func main() {
	// Create a new JSON decoder that reads from standard input.
	dec := json.NewDecoder(os.Stdin)

	// Loop through the stream of JSON objects.
	for {
		var event TestEvent
		// Decode the next JSON object from the input stream.
		if err := dec.Decode(&event); err != nil {
			// If we've reached the end of the input, break the loop.
			if err == io.EOF {
				break
			}
			// If there's another error, log it and exit.
			log.Fatalf("Error decoding JSON: %v", err)
		}

		// The standard benchmark text is contained in the "Output" field
		// of events where the "Action" is "output".
		if event.Action == "output" {
			// The Output string already contains a newline, so we use fmt.Print.
			fmt.Print(event.Output)
		}
	}
}
